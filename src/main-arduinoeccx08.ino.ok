#include <ArduinoECCX08.h>
byte signature[64];
byte message[32] = {
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 
0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F
};
byte publicKey[64];
void setup()
{
  Serial.begin(9600);
  while (!Serial);
  ECCX08.begin();
  String serialNumber = ECCX08.serialNumber();
  Serial.print("ECCX08 Serial Number = ");
  Serial.println(serialNumber);

  ECCX08.ecSign(0, message, signature);
  ECCX08.generatePublicKey(0, publicKey);
  printMessage();
  printPublicKey();
  printSignature();
}
void printMessage()
{
  Serial.println("byte message[32] = {");
  for (int i = 0; i < sizeof(message); i++)
  {
    Serial.print("0x");
    if ((message[i] >> 4) == 0)
      Serial.print("0"); // print preceeding high nibble if it's zero
    Serial.print(message[i], HEX);
    if (i != 63)
      Serial.print(", ");
    if ((31 - i) % 16 == 0)
      Serial.println();
  }
  Serial.println("};");
}
void printPublicKey()
{
  Serial.println("byte publicKey[64] = {");
  for (int i = 0; i < sizeof(publicKey); i++)
  {
    Serial.print("0x");
    if ((publicKey[i] >> 4) == 0)
      Serial.print("0"); // print preceeding high nibble if it's zero
    Serial.print(publicKey[i], HEX);
    if (i != 63)
      Serial.print(", ");
    if ((31 - i) % 16 == 0)
      Serial.println();
  }
  Serial.println("};");
}
void printSignature()
{
  Serial.println("byte signature[64] = {");
  for (int i = 0; i < sizeof(signature); i++)
  {
    Serial.print("0x");
    if ((signature[i] >> 4) == 0)
      Serial.print("0"); // print preceeding high nibble if it's zero
    Serial.print(signature[i], HEX);
    if (i != 63)
      Serial.print(", ");
    if ((31 - i) % 16 == 0)
      Serial.println();
  }
  Serial.println("};");
}
void loop()
{
}








//  bob

// #include <ArduinoECCX08.h>
// #include <ArduinoBearSSL.h>
// #include <utility/ECCX08CSR.h>
// #include <utility/ECCX08JWS.h>

// // byte signature[64];
// // byte digest[32];

// byte message[32] = {
// 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 
// 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 
// };
// byte publicKey[64] = {
// 0x98, 0x59, 0xFE, 0x69, 0x8D, 0x69, 0x82, 0x05, 0xEB, 0x3C, 0xCA, 0x40, 0x09, 0xC5, 0x4D, 0xA5, 
// 0x01, 0xC1, 0xF9, 0x1E, 0xF5, 0x0B, 0xD3, 0x37, 0x33, 0x8F, 0xE5, 0xCE, 0xE7, 0x24, 0x83, 0xC6, 
// 0x82, 0x93, 0x0A, 0x9D, 0x13, 0xAE, 0x27, 0x3B, 0xB9, 0x96, 0x3E, 0xD7, 0x82, 0x0F, 0xD7, 0xE7, 
// 0xFD, 0x40, 0x9E, 0x40, 0x75, 0x6B, 0x15, 0xF2, 0x28, 0x35, 0x5C, 0x5F, 0x4D, 0x84, 0x51, 0x2D
// };
// byte signature[64] = {
// 0x32, 0xEF, 0x16, 0x7D, 0x88, 0x69, 0x66, 0x71, 0x48, 0xA9, 0x2C, 0x77, 0xB5, 0x59, 0xDF, 0x74, 
// 0xD8, 0x35, 0x0D, 0xEB, 0xBA, 0x51, 0xBD, 0xCA, 0xCD, 0xEB, 0x4E, 0xB4, 0xE8, 0xD9, 0xCD, 0xA8, 
// 0xA4, 0xFF, 0x39, 0x21, 0xD8, 0x7A, 0x09, 0x05, 0x00, 0x9F, 0xAA, 0x14, 0x5E, 0x45, 0x1A, 0x68, 
// 0x66, 0x5D, 0x59, 0x74, 0x54, 0xB4, 0xC0, 0x8C, 0x35, 0xB0, 0xDD, 0x6B, 0xE3, 0x85, 0x75, 0x48
// };

// void setup()
// {
//   Serial.begin(9600);
//   while (!Serial);
//   ECCX08.begin(0x35);
//   String serialNumber = ECCX08.serialNumber();
//   Serial.print("ECCX08 Serial Number = ");
//   Serial.println(serialNumber);

//   if(ECCX08.ecdsaVerify(message, signature, publicKey))
//   {
//     Serial.println("Signature Verified");
//   }
//   else
//   {
//     Serial.println("Signature Failed");
//   }
// }

// void loop()
// {
// }